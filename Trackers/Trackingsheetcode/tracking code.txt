function trackMultiDayDSRs_V2() {
  const sheetId = '1rEQqvpZjFz6aO4T1br9_0mNnHMpr67yz65LCojlp-D0'; // Your actual Sheet ID
  const sheetName = 'DSR History'; // Suggest a new sheet name for this structure
  const ss = SpreadsheetApp.openById(sheetId);
  const sheet = ss.getSheetByName(sheetName) || ss.insertSheet(sheetName); // Create if not exists

  // --- Configuration ---
  const STUDENT_EMAIL_COL_INDEX = 0; // Column A (0-indexed) for Student Email
  const HISTORY_DAYS = 2; // Number of past days to track (e.g., 40 days)

  // IMPORTANT: List of student emails you expect DSRs from.
  // Make sure these *exactly* match the 'From' address in their DSR emails.
  // Pay close attention to dots, hyphens, and any aliases.
  const expectedStudentEmails = [
    'aakashjadhav.work@gmail.com',
    'chaitanyakute.work@gmail.com',
    'swapnilgaikwadwork@gmail.com',
    'adeshdevkar.ad@gmail.com',
    'anapsneha@gmail.com'
  ].map(email => email.toLowerCase()); // Convert to lowercase once for consistency

  // --- Regex for Flexible Subject Line Matching ---
  // This regex will match variations like:
  // "Daily Status Report for 10.09.2025"
  // "Daily Status Report 10.09.2025"
  // "Daily status report 10.09.2025"
  const baseSubjectRegexPattern = `daily\\s*status\\s*report(?:\\s*for)?\\s*`;

  // --- Load Processed Message IDs ---
  let processedMessageIds = JSON.parse(PropertiesService.getScriptProperties().getProperty('processedMessageIds_MultiDay_V2') || '[]');
  const initialProcessedCount = processedMessageIds.length;

  Logger.log(`Script started for DSR tracking (V2).`);
  Logger.log(`Tracking ${HISTORY_DAYS} past days.`);
  Logger.log(`Expected student emails: ${expectedStudentEmails.join(', ')}`);
  Logger.log(`Script's Time Zone: ${Session.getScriptTimeZone()}`);

  // --- Prepare Sheet Headers (Dynamic Dates) ---
  const headerRange = sheet.getRange(1, 1, 1, sheet.getLastColumn() || 1);
  let headers = headerRange.getValues()[0];
  if (headers.length === 0 || headers[STUDENT_EMAIL_COL_INDEX] !== "Student Email") {
    headers = ["Student Email"];
    sheet.getRange(1, STUDENT_EMAIL_COL_INDEX + 1).setValue("Student Email").setFontWeight("bold");
    Logger.log("Initialized 'Student Email' header.");
  }

  const dateColMap = new Map();
  for (let i = STUDENT_EMAIL_COL_INDEX + 1; i < headers.length; i++) {
    const headerValue = headers[i];
    if (headerValue instanceof Date) {
      dateColMap.set(Utilities.formatDate(headerValue, Session.getScriptTimeZone(), "yyyy-MM-dd"), i);
    } else if (typeof headerValue === 'string' && /^\d{4}-\d{2}-\d{2}$/.test(headerValue)) { // Ensure it looks like a date string
      dateColMap.set(headerValue, i);
    }
  }
  Logger.log(`Initial date columns found: ${Array.from(dateColMap.keys()).join(', ')}`);


  // --- Populate Student Emails in the first column ---
  const studentEmailsInSheetRange = sheet.getRange(2, STUDENT_EMAIL_COL_INDEX + 1, sheet.getLastRow() - 1 || 1, 1);
  // Get existing student emails, handle empty ranges
  const existingEmailsFlat = (studentEmailsInSheetRange.getValues() || []).flat();
  const studentEmailsInSheet = existingEmailsFlat.map(email => email ? email.toString().toLowerCase() : '');

  const studentEmailRowMap = new Map(); // Map: lowerCaseEmail -> rowNumber (1-indexed)

  let currentRow = sheet.getLastRow() + 1; // Start appending after the last existing row
  for (const email of expectedStudentEmails) {
    const lowerCaseEmail = email.toLowerCase();
    let rowNumIndex = studentEmailsInSheet.indexOf(lowerCaseEmail);
    
    if (rowNumIndex === -1) {
      // Student not found in sheet, append new row
      sheet.getRange(currentRow, STUDENT_EMAIL_COL_INDEX + 1).setValue(email);
      studentEmailRowMap.set(lowerCaseEmail, currentRow);
      Logger.log(`Added new student '${email}' at row ${currentRow}`);
      currentRow++;
    } else {
      // Student found, use existing row
      studentEmailRowMap.set(lowerCaseEmail, rowNumIndex + 2); // +2 for 0-indexed array + header row
    }
  }
  Logger.log(`Student email rows map: ${JSON.stringify(Array.from(studentEmailRowMap))}`);

  // --- Iterate through past days ---
  const todayForLoop = new Date();
  let totalDSRsProcessed = 0;

  for (let d = 0; d < HISTORY_DAYS; d++) {
    const targetDate = new Date(todayForLoop);
    targetDate.setDate(todayForLoop.getDate() - d); // Go back d days

    const dsrDateFormat = Utilities.formatDate(targetDate, Session.getScriptTimeZone(), "dd.MM.yyyy"); // For subject matching (e.g., 10.09.2025)
    const displayDateFormat = Utilities.formatDate(targetDate, Session.getScriptTimeZone(), "yyyy-MM-dd"); // For sheet header/cell content (e.g., 2025-09-10)

    Logger.log(`--- Processing date: ${displayDateFormat} (DSR subject format: ${dsrDateFormat}) ---`);

    // --- Ensure Date Column Exists ---
    let colIndex = dateColMap.get(displayDateFormat);
    if (colIndex === undefined) {
      colIndex = sheet.getLastColumn();
      if (colIndex < STUDENT_EMAIL_COL_INDEX) colIndex = STUDENT_EMAIL_COL_INDEX; // Ensure it starts after student emails
      colIndex++; // Move to the next available column (0-indexed)

      sheet.getRange(1, colIndex + 1).setValue(displayDateFormat).setFontWeight("bold");
      dateColMap.set(displayDateFormat, colIndex);
      headers[colIndex] = displayDateFormat; // Update headers array for internal consistency
      Logger.log(`Added new date column for ${displayDateFormat} at column ${colIndex + 1}`);
    }

    // --- Search for DSRs for this specific targetDate ---
    const currentDaySubjectRegex = new RegExp(
      baseSubjectRegexPattern + dsrDateFormat.replace(/\./g, '\\.'), 'i'
    );
    Logger.log(`Regex for this date: ${currentDaySubjectRegex}`);

    // Modified Gmail search query: Broaden the initial search by removing "newer_than"
    // and letting the regex handle the date in the subject.
    const gmailSearchQuery = `subject:"Daily Status Report" ${dsrDateFormat} is:unread OR is:read`;
    // We remove newer_than to avoid missing older emails.
    // "is:unread OR is:read" just ensures it searches all messages, not just unread.
    Logger.log(`Gmail search query: ${gmailSearchQuery}`);

    const threads = GmailApp.search(gmailSearchQuery, 0, 500); // Limit results for efficiency
    Logger.log(`Found ${threads.length} threads for ${displayDateFormat} with broad search.`);
    const foundDSRsForDate = new Set(); // Stores studentEmail for whom DSR was found for this date

    for (const thread of threads) {
      const messages = thread.getMessages();
      for (const message of messages) {
        const messageId = message.getId();

        if (processedMessageIds.includes(messageId)) {
          // Logger.log(`Skipping already processed message ID: ${messageId}`);
          continue;
        }

        const sender = message.getFrom();
        const subject = message.getSubject();

        // Extract just the email address from 'Sender Name <email@example.com>'
        const senderEmailMatch = sender.match(/<([^>]+)>/);
        const extractedEmail = senderEmailMatch ? senderEmailMatch[1].toLowerCase() : sender.toLowerCase();

        // Check if it's an expected student AND the subject matches our flexible regex
        if (expectedStudentEmails.includes(extractedEmail) && currentDaySubjectRegex.test(subject)) {
          foundDSRsForDate.add(extractedEmail);
          processedMessageIds.push(messageId); // Mark as processed
          totalDSRsProcessed++;
          Logger.log(`  MATCH: Student ${extractedEmail} for date ${displayDateFormat} with subject: "${subject}"`);
        } else {
          // Logger.log(`  SKIP: Email from ${extractedEmail} with subject: "${subject}" for ${displayDateFormat}. Expected: ${expectedStudentEmails.includes(extractedEmail)}, Regex: ${currentDaySubjectRegex.test(subject)}`);
        }
      }
    }

    // --- Update Status in Sheet for this Date Column ---
    for (const studentEmail of expectedStudentEmails) {
      const lowerCaseStudentEmail = studentEmail.toLowerCase();
      const rowNum = studentEmailRowMap.get(lowerCaseStudentEmail); // 1-indexed row in sheet

      if (!rowNum) {
        Logger.log(`Error: Student ${studentEmail} not found in row map for status update. This should not happen.`);
        continue;
      }

      const statusCell = sheet.getRange(rowNum, colIndex + 1); // +1 because getRange is 1-indexed
      const isDSRFound = foundDSRsForDate.has(lowerCaseStudentEmail);
      const status = isDSRFound ? "Sent" : "Not Sent";

      // Only update if current value is different to avoid unnecessary writes/flushing
      if (statusCell.getValue() !== status) {
        statusCell.setValue(status);
        statusCell.setBackground(isDSRFound ? '#e6ffe6' : '#ffe6e6'); // Light Green / Light Red
        statusCell.setFontColor(isDSRFound ? '#006400' : '#8B0000'); // Dark Green / Dark Red
        statusCell.setFontWeight("bold");
        statusCell.setHorizontalAlignment("center");
        Logger.log(`  Updated status for ${lowerCaseStudentEmail} on ${displayDateFormat} to: ${status}`);
      }
    }
  } // End of loop through HISTORY_DAYS

  // --- Save Processed Message IDs ---
  if (processedMessageIds.length > initialProcessedCount) {
    PropertiesService.getScriptProperties().setProperty('processedMessageIds_MultiDay_V2', JSON.stringify(processedMessageIds));
    Logger.log(`Updated processedMessageIds property with ${processedMessageIds.length - initialProcessedCount} new IDs.`);
  }

  Logger.log(`Script finished. Total DSRs newly processed in this run: ${totalDSRsProcessed}.`);
}